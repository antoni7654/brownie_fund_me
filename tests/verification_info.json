{'standard_json_input': {'language': 'Solidity', 'sources': {'FundMe.sol': {'content': ' // SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.6;\n\n/// @notice Explain to an end user what this does\n/// @dev Explain to a developer any extra details\n/// @return Documents the return variables of a contractâ€™s function state variable\n/// @inheritdoc\tCopies all missing tags from the base function (must be followed by the contract name)\nimport "AggregatorV3Interface.sol";\n\n// import "SafeMathChainlink.sol";\n// import "AggregatorV3Interface.sol";\n\n// 
    import "SafeMathChainlink.sol"; -> ya no se usa\n\ncontract FundMe {\n // using SafeMathChainlink for uint256;\n\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n    address public owner;\n    AggregatorV3Interface public priceFeed;\n\n    // if you\'re following along with the freecodecamp video\n    // Please see https://github.com/PatrickAlphaC/fund_me\n    // to get the starting solidity contract code, it\'ll be slightly different than this!\n    constructor(address _priceFeed) public {\n        priceFeed 
    = AggregatorV3Interface(_priceFeed);\n        owner = msg.sender;\n
                }\n\n    function fund() public payable {\n        uint256 minimumUSD 
    = 50 * 10**18;\n        require(\n            getConversionRate(msg.value) >= minimumUSD,\n            "You need to spend more ETH!"\n       
     );\n        addressToAmountFunded[msg.sender
                    ] += msg.value;\n        funders.push(msg.sender);\n
                }\n\n    function getVersion() public view returns (uint256) {\n        return priceFeed.version();\n
                }\n\n    function getPrice() public view returns (uint256) {\n        (, int256 answer,
                    ,
                    , ) = priceFeed.latestRoundData();\n        return uint256(answer * 10000000000);\n
                }\n\n // 1000000000\n    function getConversionRate(uint256 ethAmount)\n        public\n        view\n        returns (uint256)\n    {\n        uint256 ethPrice = getPrice();\n  
          uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1000000000000000000;\n        return ethAmountInUsd;\n
            }\n\n    function getEntranceFee() public view returns (uint256) {\n // minimumUSD\n        uint256 minimumUSD = 50 * 10**18;\n        uint256 price = getPrice();\n        uint256 precision = 1 * 10**18;\n        // return (minimumUSD * precision) / price;\n        // We fixed a rounding error found in the video by adding one!\n        return ((minimumUSD * precision) / price) + 1;\n    }\n\n    //modifier: https://medium.com/coinmonks/solidity-tutorial-all-about-modifiers-a86cf81c14cb\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    
    function withdraw() public payable onlyOwner {\n // address payable p_msg_sender = payable(msg.sender);\n        // p_msg_sender.transfer(address(this).balance);\n        payable(msg.sender).transfer(address(this).balance);\n\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            address funder = funders[funderIndex];\n 
               addressToAmountFunded[funder
                    ] = 0;\n
                }\n        funders = new address[](0);\n
            }\n
        }\n'
    }, 'AggregatorV3Interface.sol': {'content': ' // SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view 
    returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n // getRoundData and latestRoundData should both raise "No data present"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n'}, 'SafeMathChainlink.sol': {'content': '// SPDX-License-Identifier: MIT\npragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity\'s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class 
    of bugs, so it\'s recommended to use it always.\n */\nlibrary SafeMathChainlink {\n /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity\'s `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a,
                "SafeMath: addition overflow");\n\n    return c;\n
            }\n\n /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    
    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity\'s `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a,
                "SafeMath: subtraction overflow");\n    uint256 c = a - b;\n\n    return c;\n
            }\n\n /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity\'s `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n // Gas optimization: this is cheaper than requiring \'a\' not being zero, but the\n    // benefit is lost if \'b\' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, "SafeMath: multiplication overflow");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity\'s `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, "SafeMath: division by zero");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\'t hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity\'s `%` 
    operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to 
    revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0,
                    "SafeMath: modulo by zero");\n    return a % b;\n
                }\n
            }\n'
        }
    }, 'settings': {'evmVersion': 'istanbul', 'optimizer': {'enabled': True, 'runs': 200
        }, 'libraries': {'FundMe.sol': {}
        }
    }
}, 'contract_name': 'FundMe', 'compiler_version': '0.8.15+commit.e14f2714', 'optimizer_enabled': True, 'optimizer_runs': 200, 'license_identifier': 'MIT', 'bytecode_len': 4208
}